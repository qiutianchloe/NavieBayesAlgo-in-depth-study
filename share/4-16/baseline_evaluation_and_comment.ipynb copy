{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "import seaborn as sns\n",
    "\n",
    "import math\n",
    "from collections import defaultdict\n",
    "from functools import reduce"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "################################\n",
    "class ClassCounter:\n",
    "    def __init__(self, subject):\n",
    "        #initialize the subject name\n",
    "        self.subject = subject\n",
    "\n",
    "    def prepare(self, class_num):\n",
    "        #initialize the array which is to count how many elements are there in each class\n",
    "        #initialize the array which store the percentage of numbers of each class in the total numbers of instance\n",
    "        self.__classes_count = [0] * class_num\n",
    "        self.__classes_prob = [0] * class_num\n",
    "        \n",
    "    def add(self, class_index):\n",
    "        #count how many elements are there in each class\n",
    "        self.__classes_count[class_index] += 1\n",
    "    \n",
    "    def run(self):\n",
    "        #calculate how many elements are there in total \n",
    "        print(self.__classes_count)\n",
    "        total = sum(self.__classes_count)\n",
    "        #calculate the percentage of numbers of each class in the total numbers of instance\n",
    "        for index, val in enumerate(self.__classes_count):\n",
    "            self.__classes_prob[index] = val/total\n",
    "    \n",
    "    def get(self):\n",
    "        #return the percentage of numbers of each class in the total numbers of instance\n",
    "        return tuple(self.__classes_prob)\n",
    "    \n",
    "    def get_classes_count(self):\n",
    "        #return how many elements are there in each class\n",
    "        return self.__classes_count"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Father class to count the elements of attribute\n",
    "class AttrCounter:\n",
    "    def __init__(self, name):\n",
    "        #store the name of the attribute \n",
    "        self.name = name\n",
    "\n",
    "    def prepare(self, class_num):\n",
    "        #initialize the container to store the elements\n",
    "        return\n",
    "    \n",
    "    def add(self, attr, class_index):\n",
    "        #precess the dataset and instore the elements in to the container that initialized in thre prepare function\n",
    "        return \n",
    "    \n",
    "    def run(self):\n",
    "        #calculate the precentage\n",
    "        return \n",
    "    \n",
    "    def get(self, attr):\n",
    "        #returm the precentage\n",
    "        return 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [],
   "source": [
    "#son class to counter the elemnts of nominal attibute\n",
    "class NomCounter(AttrCounter):\n",
    "    __smooth_alpha = 1\n",
    "    \n",
    "    def __init__(self, name):\n",
    "        #store the name of this attribute\n",
    "        super().__init__(name)\n",
    "\n",
    "    def prepare(self, class_num):\n",
    "        #store all the possible values of an attribute in a set\n",
    "        self.__attr_vals = set()\n",
    "        #for each class values, create a dictionary to store the corresponding numbers of this attribute values\n",
    "        self.__attr_count = [defaultdict(int) for i in range(class_num)]\n",
    "        #for each class values, create a dictionary to store the corresponding precentage of this attribute values(the target value)\n",
    "        self.__attr_prob = [defaultdict(float) for i in range(class_num)]\n",
    "    \n",
    "    def add(self, attr, class_index):\n",
    "        #add the attribute values\n",
    "        self.__attr_vals.add(attr)\n",
    "        #add the number of attribute value in corresponding class\n",
    "        self.__attr_count[class_index][attr] += 1\n",
    "    \n",
    "    def run(self):\n",
    "        #number of attribute in the dataset\n",
    "        dimension = len(self.__attr_vals)\n",
    "        #to calculate the precentage of each attribute value precentage in this particular class\n",
    "        for index, attrs in enumerate(self.__attr_count):\n",
    "            total = reduce(lambda x, y: x + y, attrs.values())\n",
    "            for val in self.__attr_vals:\n",
    "                self.__attr_prob[index][val] = self._laplace_smooth(attrs[val], total, dimension)\n",
    "    \n",
    "    def get(self, attr): \n",
    "        #return the precentage\n",
    "        return tuple(prob[attr] for prob in self.__attr_prob)\n",
    "    \n",
    "    #use Laplace smoothing to replace the zero value\n",
    "    def _laplace_smooth(self, num, total, dimension):\n",
    "        return (num+self.__smooth_alpha)/(total+dimension*self.__smooth_alpha)\n",
    "    \n",
    "return_value ='''\n",
    "The example after running this class\n",
    "            self.__attr_val\n",
    "            ---------------\n",
    "            {'high', 'med', 'vhigh', 'low'}\n",
    "            \n",
    "            self.__attr_count\n",
    "            -----------------\n",
    "            [defaultdict(<class 'int'>, {'vhigh': 360, 'high': 324, 'med': 268, 'low': 258}), \n",
    "             defaultdict(<class 'int'>, {'vhigh': 72, 'high': 108, 'med': 115, 'low': 89}), \n",
    "             defaultdict(<class 'int'>, {'med': 23, 'low': 46, 'high': 0, 'vhigh': 0}), \n",
    "             defaultdict(<class 'int'>, {'med': 26, 'low': 39, 'high': 0, 'vhigh': 0})]\n",
    "             \n",
    "            self.__attr_prob\n",
    "            ----------------\n",
    "            [defaultdict(<class 'float'>, {'high': 0.2677100494233937, 'med': 0.2215815485996705, 'vhigh': 0.29736408566721584, 'low': 0.21334431630971992}), \n",
    "             defaultdict(<class 'float'>, {'high': 0.2809278350515464, 'med': 0.29896907216494845, 'vhigh': 0.18814432989690721, 'low': 0.23195876288659795}), \n",
    "             defaultdict(<class 'float'>, {'high': 0.0136986301369863, 'med': 0.3287671232876712, 'vhigh': 0.0136986301369863, 'low': 0.6438356164383562}), \n",
    "             defaultdict(<class 'float'>, {'high': 0.014492753623188406, 'med': 0.391304347826087, 'vhigh': 0.014492753623188406, 'low': 0.5797101449275363})]\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "#son class to counte the element of the numberical attributes\n",
    "class NumCounter(AttrCounter):\n",
    "    \n",
    "    def __init__(self, name):\n",
    "        #store the name of this attribute\n",
    "        super().__init__(name)\n",
    "\n",
    "    def prepare(self, class_num):\n",
    "        #for each class, create the container to store the corresponding attribute values\n",
    "        self.__attr_data = [[] for i in range(class_num)]\n",
    "        #for each class,calculate the mean of this attribute(the target value)\n",
    "        self.__mean = [0] * class_num\n",
    "        #for each class, calculate the deviation of this attribute(the target value)\n",
    "        self.__deviation = [0] * class_num\n",
    "    \n",
    "    def add(self, attr, class_index):\n",
    "        #to store all the values into the container\n",
    "        self.__attr_data[class_index].append(float(attr))\n",
    "    \n",
    "    def run(self):\n",
    "        #use the values that stored in the container to calculate the mean values adn deviation values \n",
    "        for index, data in enumerate(self.__attr_data):\n",
    "            #calculate the mean value\n",
    "            mean = sum(data)/len(data)\n",
    "            #calculate the deviation values\n",
    "            deviation = math.sqrt(sum([(x - mean)**2 for x in data])/(len(data)-1))\n",
    "            #set the mean inside the class\n",
    "            self.__mean[index] = mean\n",
    "            #set the deviation inside the class\n",
    "            self.__deviation[index] = deviation\n",
    "    \n",
    "    def get(self, attr):\n",
    "        #return the normal distribution\n",
    "        return tuple(self._normal_distribution(float(attr), self.__mean[i], self.__deviation[i]) for i in range(len(self.__mean)))\n",
    "    \n",
    "    def _normal_distribution(self, val, mean, deviation):\n",
    "        ###to calculate the normal distribution\n",
    "        return 1/(deviation*math.sqrt(2*math.pi))*np.exp(-((val-mean)/deviation)**2/2) if deviation > 0 else 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Num2NomCounter(NomCounter):  \n",
    "    def __init__(self, name, bins):\n",
    "        assert(bins >= 2)\n",
    "        super().__init__(name)\n",
    "        self.__bins = bins\n",
    "\n",
    "    def prepare(self, class_num):\n",
    "        self.__split = [0] * (self.__bins-1)\n",
    "        self.__attr_data = []\n",
    "        self.__attr_count = [[0]*self.__bins for i in range(class_num)]\n",
    "        self.__attr_prob = [[0]*self.__bins for i in range(class_num)]\n",
    "    \n",
    "    def add(self, attr, class_index):\n",
    "        self.__attr_data.append((float(attr), class_index))\n",
    "    \n",
    "    def run(self):\n",
    "        self.__attr_data.sort()\n",
    "        gaps = self.__split_integer(len(self.__attr_data),self.__bins)\n",
    "        cur = 0\n",
    "        for i in range(self.__bins-1):\n",
    "            npos = sum(gaps[:i+1])\n",
    "            self.__split[i] = self.__attr_data[npos][0]\n",
    "            for j in range(cur, npos):\n",
    "                self.__attr_count[self.__attr_data[j][1]][i] += 1\n",
    "            cur = npos\n",
    "        for j in range(cur, len(self.__attr_data)):\n",
    "            self.__attr_count[self.__attr_data[j][1]][i+1] += 1           \n",
    "        for index,attrs in enumerate(self.__attr_count):\n",
    "            total = reduce(lambda x, y: x + y, attrs)\n",
    "            for val, num in enumerate(attrs):\n",
    "                self.__attr_prob[index][val] = self._laplace_smooth(num, total, self.__bins)\n",
    "        # print(self.__split)\n",
    "        # print(self.__attr_count)\n",
    "        # print(self.__attr_prob)\n",
    "        # print(\"____________\")\n",
    "    \n",
    "    def get(self, attr):\n",
    "        attr = float(attr)\n",
    "        for i in range(self.__bins):\n",
    "            if i >= len(self.__split) or attr < self.__split[i]:\n",
    "                break\n",
    "        return tuple(prob[i] for prob in self.__attr_prob)\n",
    "    \n",
    "    def __split_integer(self, m, n):\n",
    "        quotient = int(m / n)\n",
    "        remainder = m % n\n",
    "        if remainder > 0:\n",
    "            return [quotient] * (n - remainder) + [quotient + 1] * remainder\n",
    "        if remainder < 0:\n",
    "            return [quotient - 1] * -remainder + [quotient] * (n + remainder)\n",
    "        return [quotient] * n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "    \n",
    "class Nom2NumCounter(NumCounter):\n",
    "    def __init__(self, name, mapper):\n",
    "        super().__init__(name)\n",
    "        self.__mapper = mapper\n",
    "    \n",
    "    def add(self, attr, class_index):\n",
    "        self._attr_data[class_index].append(self.__mapper(attr))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Evaluation:\n",
    "#     num_of_class = 0\n",
    "#     num_of_inst = 0\n",
    "#     result = []\n",
    "#     multiclass_matrix=None\n",
    "#     correct_pre = []\n",
    "#     actual_num = []\n",
    "#     predict_num = []\n",
    "    \n",
    "    def __init__(self,result,num_of_class):\n",
    "        #the input(list of tuples, tuple has two value, first one is real class value, second is the predict one)\n",
    "        self.result = result\n",
    "        #number of class\n",
    "        self.num_of_class = num_of_class\n",
    "        #number of instances\n",
    "        self.num_of_inst = len(result)\n",
    "        #generate the muticlass matrix(that mentions in the lecture slide)\n",
    "        self.multiclass_matrix = self.generate_matrix()\n",
    "        #use the multiclass matrix to generte some value that we need to evaluate the model\n",
    "        self.precess_matrix()\n",
    "    \n",
    "    def generate_matrix(self):\n",
    "        matrix = np.zeros((self.num_of_class, self.num_of_class))\n",
    "        for tup in self.result:\n",
    "            matrix[tup[0]][tup[1]]+=1\n",
    "        return matrix\n",
    "    \n",
    "    def precess_matrix(self):\n",
    "        #fill in these array \n",
    "        #the values on the matrix diagonal, how many numbers of instance that the model correctly predict for this particular class\n",
    "        self.correct_pre = [self.multiclass_matrix[i][i] for i in range(self.num_of_class)]\n",
    "        #the actual numbers of instance that each class has in this dataset(TP+FN)\n",
    "        self.actual_num = [self.multiclass_matrix[i].sum() for i in range(self.num_of_class)]\n",
    "        #all numbers of instance that we predict for each class(TP+FP)\n",
    "        self.predict_num = [self.multiclass_matrix[:,i].sum() for i in range(self.num_of_class)]\n",
    "    \n",
    "    \n",
    "    def calculate_accuracy(self):\n",
    "        #calculate the accuracy\n",
    "        accuracy = sum(self.correct_pre)/sum(self.actual_num)\n",
    "        return accuracy\n",
    "    \n",
    "    def calculate_Macro_value(self):   \n",
    "        ###precision###\n",
    "        temp_arr1 = []\n",
    "        #calculate the precision by its formula\n",
    "        for i in range(self.num_of_class):\n",
    "            #if there is any value is 0, then store 0(otherwise, denominator will be zero)\n",
    "            if(self.correct_pre[i]==0 or self.predict_num[i]==0):\n",
    "                temp_arr1.append(0)\n",
    "            else:\n",
    "                this_pre = self.correct_pre[i]/self.predict_num[i]\n",
    "                temp_arr1.append(this_pre)\n",
    "        precision = sum(temp_arr1)/self.num_of_class\n",
    "            \n",
    "        ###recall###\n",
    "        temp_arr2 = []\n",
    "        #calculate the recall by its formula\n",
    "        for i in range(self.num_of_class):\n",
    "            #if there is any value is 0, then store 0(otherwise, denominator will be zero)\n",
    "            if(self.correct_pre[i]==0 or self.actual_num[i]==0):\n",
    "                temp_arr2.append(0)\n",
    "            else:\n",
    "                this_recall = self.correct_pre[i]/self.actual_num[i]\n",
    "                temp_arr2.append(this_recall)\n",
    "        recall = sum(temp_arr2)/self.num_of_class\n",
    "        \n",
    "        return [precision, recall]\n",
    "    \n",
    "    \n",
    "    def calculate_Micro_value(self):\n",
    "        ###precision###\n",
    "        precision = sum(self.correct_pre)/sum(self.predict_num)\n",
    "        ###recall###\n",
    "        recall = sum(self.correct_pre)/sum(self.actual_num)\n",
    "        return [precision, recall]\n",
    "    \n",
    "    def calculate_weight_value(self):\n",
    "        ###precision###\n",
    "        temp_arr1 = []\n",
    "        #calculate the precision by its formula\n",
    "        for i in range(self.num_of_class):\n",
    "            #if there is any value is 0, then store 0(otherwise, denominator will be zero)\n",
    "            if(self.correct_pre[i]==0 or self.predict_num[i]==0):\n",
    "                temp_arr1.append(0)\n",
    "            else:\n",
    "                this_pre = (self.actual_num[i]/self.num_of_inst)*(self.correct_pre[i]/self.predict_num[i])\n",
    "                temp_arr1.append(this_pre)\n",
    "        precision = sum(temp_arr1)     \n",
    "        ###recall###\n",
    "        temp_arr2 = []\n",
    "        #calculate the recall by its formula\n",
    "        for i in range(self.num_of_class):\n",
    "            #if there is any value is 0, then store 0(otherwise, denominator will be zero)\n",
    "            if(self.correct_pre[i]==0 or self.actual_num[i]==0):\n",
    "                temp_arr2.append(0)\n",
    "            else:\n",
    "                this_recall = (self.actual_num[i]/self.num_of_inst)*(self.correct_pre[i]/self.actual_num[i])\n",
    "                temp_arr2.append(this_recall)\n",
    "        recall = sum(temp_arr2)\n",
    "        \n",
    "        return [precision, recall]\n",
    "        \n",
    "        \n",
    "    def draw_heatmap_d(self):\n",
    "        #draw the heatmap with numbers of instance on it\n",
    "        sns.heatmap(self.multiclass_matrix, vmin=0, vmax=len(self.result), annot=True,cmap=\"RdPu_r\", fmt='.20g')\n",
    "        plt.show()\n",
    "        \n",
    "    def draw_heatmap_f(self):\n",
    "        #draw the heatmap with precentage on it\n",
    "        sns.heatmap(self.multiclass_matrix/len(self.result), vmin=0, vmax=1, annot=True,cmap=\"RdPu_r\", fmt='.2g')\n",
    "        plt.show()  \n",
    "        \n",
    "    def draw_bar_chart(self):\n",
    "        #draw the bar chart\n",
    "        #for each class\n",
    "        #show the numbers of predict value, actual value, correctly predict value\n",
    "        names = [\"calss\"+str(i) for i in range(self.num_of_class)]\n",
    "        plt.figure(figsize=(10,6), dpi=80)\n",
    "        x = range(len(names))\n",
    "        \n",
    "        plt.bar(x, self.actual_num, width=0.1)\n",
    "        plt.bar([i + 0.1 for i in x], self.predict_num, width=0.1)\n",
    "        plt.bar([i + 0.2 for i in x], self.correct_pre, width=0.1)\n",
    "\n",
    "        plt.xticks([i + 0.05 for i in x], names)\n",
    "        \n",
    "        plt.xlabel('Class Name', fontsize=14)\n",
    "        plt.ylabel('Number Of Each Class', fontsize=14)\n",
    "        plt.show()\n",
    "        \n",
    "        \n",
    "    def evaluate(self):\n",
    "        ################################Calculate Accuracy##################################\n",
    "        accuracy = self.calculate_accuracy()\n",
    "        print(self.correct_pre,self.actual_num, self.predict_num)\n",
    "        print(\"accuracy is: %f\" %accuracy)\n",
    "        print(\"error rate is: %f\"%(1-accuracy))\n",
    "\n",
    "        ##macro averaging\n",
    "        precisionMa, recallMa = self.calculate_Macro_value()\n",
    "        print(\"\\n\\n----------------the macro averaging way------------------\")\n",
    "        print(\"Marco averaging precision is: \",precisionMa)\n",
    "        print(\"Marco averaging recall is:\",recallMa)\n",
    "        \n",
    "        #micro averaging\n",
    "        precisionMi, recallMi = self.calculate_Micro_value()\n",
    "        print(\"----------------the micro averaging way------------------\")\n",
    "        print(\"Mirco averaging precision is:\", precisionMi)\n",
    "        print(\"Mirco averaging recall is:\", recallMi)\n",
    "        \n",
    "        #weight averaging\n",
    "        precisionWe, recallWe = self.calculate_weight_value()\n",
    "        print(\"----------------the weight averaging way------------------\")\n",
    "        print(\"weight averaging precision is:\" ,precisionWe)\n",
    "        print(\"weight averaging recall is:\" ,recallWe)\n",
    "        \n",
    "        ###################################Draw Graphs######################################\n",
    "        #self.draw_heatmap_d()\n",
    "        #self.draw_heatmap_f()\n",
    "        #self.draw_bar_chart()\n",
    "        \n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Model:\n",
    "    def __init__(self, classes, *counters):\n",
    "        self.num = 10\n",
    "        #convert the class name(string) into the number(start from 0), like class name1 = 0, class name2 = 1, class name3 = 2, etc.\n",
    "        return_value = '''eg. {'unacc': 0, 'acc': 1, 'good': 2, 'vgood': 3}'''\n",
    "        self.__classes = {classname:index for index,classname in enumerate(classes)}\n",
    "        #it is a tuple to store all initialized particular attribute(in the particular type class)\n",
    "        self.__counters = counters\n",
    "        #initialize the filters\n",
    "        self.__filters = ()\n",
    "        #to judge whether we need to delete the first column (some time the first colum is the serial number)\n",
    "        self.__dump_firt_column = False\n",
    "        for index, counter in enumerate(counters):\n",
    "            #if the counter is a class type counter\n",
    "            if isinstance(counter, ClassCounter):\n",
    "                #set the position of the target class column in this Model class \n",
    "                self.__classpos = index\n",
    "            #use the function in the class to prepare the each attribute  (which is initialze all the attributes values container)\n",
    "            counter.prepare(len(classes))\n",
    "            \n",
    "    def set_filters(self, filters):\n",
    "        #set the particular filters\n",
    "        #because different datasets has different punctuation to represent the missing value\n",
    "        #so we need to set the particular filters to particular punctuation\n",
    "        self.__filters = filters\n",
    "        \n",
    "    def set_dump_firt_column(self, enabled):\n",
    "        #set whether we need to delete the first column (some time the first colum is the serial number)\n",
    "        self.__dump_firt_column = enabled\n",
    "            \n",
    "    def preprocess(self, lines):\n",
    "        #we will read the file line by line, so that we gonna preprocess the data line by line\n",
    "        for line in lines:\n",
    "            #split all the data in a line\n",
    "            inputs = line.strip().split(\",\")[1:] if self.__dump_firt_column else line.strip().split(\",\")\n",
    "            #if we successfully read the file lines into the program, continue running this preprocess function\n",
    "            if not inputs or not inputs[0]:\n",
    "                continue\n",
    "                \n",
    "            ###DEALING WITH CLASS VALUE###\n",
    "            #find out the class value of this instance\n",
    "            class_index = self.__classes[inputs[self.__classpos]]\n",
    "            ###DEALING WITH EACH ATTRIBUTE VALUE\n",
    "            #read in all the values and use their particular way to store into their value container \n",
    "            for i, val in enumerate(inputs):\n",
    "                ########!!!!!########\n",
    "                #if there is no missing value, continue store the instance inside the attribute class container, \n",
    "                #otherwise discard this instance (we choose this way to deal with the missing value which will explain in the written example)\n",
    "                if val not in self.__filters:\n",
    "                    #if this is the value of the target class\n",
    "                    if i == self.__classpos:\n",
    "                        #add value in the ClassCounter\n",
    "                        self.__counters[i].add(class_index)\n",
    "                    else:\n",
    "                        #otherwise add value in their own AttriCounter\n",
    "                        self.__counters[i].add(val, class_index)\n",
    "                \n",
    "    def train(self):\n",
    "        #train the training set by running the function in their class\n",
    "        for counter in self.__counters:\n",
    "            counter.run()\n",
    "\n",
    "    def test(self, lines):\n",
    "        self.res = []\n",
    "        flag = 1\n",
    "        #we still need to read the file line by line, so that we gonna preprocess the test data line by line\n",
    "        for line in lines:\n",
    "            #split all the data in the line\n",
    "            inputs = line.strip().split(\",\")[1:] if self.__dump_firt_column else line.strip().split(\",\")\n",
    "            #if we successfully read the file lines into the program, continue running this preprocess function \n",
    "            if not inputs or not inputs[0]:\n",
    "                continue\n",
    "            \n",
    "            #real target class type of this instance\n",
    "            real = self.__classes[inputs[self.__classpos]]\n",
    "            #all the predict value \n",
    "            predict = []\n",
    "            \n",
    "            for i, val in enumerate(inputs):\n",
    "                #if there is no missing value, continue store the instance inside the attribute class container, \n",
    "                #otherwise discard this instance (we choose this way to deal with the missing value which will explain in the written example)\n",
    "                if val not in self.__filters:\n",
    "                    #caluculate the presentage that each type that this instance might have\n",
    "                    if i == self.__classpos:\n",
    "                        predict.append(np.log2(np.array(self.__counters[i].get())))\n",
    "                    else:\n",
    "                        predict.append(np.log2(np.array(self.__counters[i].get(val))))\n",
    "            #store the real value and our predict value in a tuple(real value, predict value)\n",
    "            self.res.append((real, np.argmax(reduce(lambda x, y: x*y, predict))))\n",
    "        return self.res\n",
    "    \n",
    "    def train_zero_R_baseline(self):\n",
    "        for counter in self.__counters:\n",
    "            #if the counter is a class type counter\n",
    "            if isinstance(counter, ClassCounter):\n",
    "                #get the each number of times class happened at dataset(which store at the ClassCounter) eg.[3630(class0), 1152(class1), 207(class2), 195(class3)]\n",
    "                self.__class_count = counter.get_classes_count()\n",
    "                #find out the class that happened for most of time\n",
    "                maximum_class = self.__class_count[0]\n",
    "                #return its index(which is the index that represent the class)\n",
    "                self.___majority_class_index = 0\n",
    "                #start to find that class\n",
    "                for i in range(len(self.__class_count)):\n",
    "                    if(self.__class_count[i]>maximum_class):\n",
    "                        maximum_class = self.__class_count[i]\n",
    "                        self.___majority_class_index = i\n",
    "                        \n",
    "    def test_zero_R_baseline(self, lines):\n",
    "        self.res = []\n",
    "        #we still need to read the file line by line, so that we gonna preprocess the test data line by line\n",
    "        for line in lines:\n",
    "            #split all the data in the line\n",
    "            inputs = line.strip().split(\",\")[1:] if self.__dump_firt_column else line.strip().split(\",\")\n",
    "            #if we successfully read the file lines into the program, continue running this preprocess function \n",
    "            if not inputs or not inputs[0]:\n",
    "                continue\n",
    "            #real target class type of this instance\n",
    "            real = self.__classes[inputs[self.__classpos]]\n",
    "            #and predict all the class value of test instance as the class that occur for the most of time\n",
    "            self.res.append((real,self.___majority_class_index))\n",
    "        return self.res\n",
    "    \n",
    "    def evaluate(self):\n",
    "        evaluate_result = Evaluation(self.res, len(self.__classes))\n",
    "        evaluate_result.evaluate()   \n",
    "        return evaluate_result\n",
    "        \n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Dataset initialization "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 40,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''car Dataset'''\n",
    "'''-----------------------------------------------------------------------------'''\n",
    "#目标data文件\n",
    "filename = \"datasets/car.data\"\n",
    "#文件中的class名称\n",
    "classes = (\"unacc\" , \"acc\", \"good\", \"vgood\")\n",
    "#设置model\n",
    "model = Model(\n",
    "    classes,\n",
    "    NomCounter(\"buying\"),\n",
    "    NomCounter(\"maint\"),\n",
    "    NomCounter(\"doors\"),\n",
    "    NomCounter(\"persons\"),\n",
    "    NomCounter(\"lug_boot\"),\n",
    "    NomCounter(\"safety\"),\n",
    "    ClassCounter(\"Car Evaluation\")\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Adult Dataset'''\n",
    "'''-----------------------------------------------------------------------------'''\n",
    "filename = \"datasets/adult.data\"\n",
    "classes = (\"<=50K\" , \">50K\")\n",
    "model = Model(\n",
    "    classes,\n",
    "    NumCounter(\"age\"),\n",
    "    NomCounter(\"workclass\"),\n",
    "    NumCounter(\"fnlwgt\"),\n",
    "    NomCounter(\"education\"),\n",
    "    NomCounter(\"education-num\"),\n",
    "    NomCounter(\"marital-status\"),\n",
    "    NomCounter(\"occupation\"),\n",
    "    NomCounter(\"relationship\"),\n",
    "    NomCounter(\"race\"),\n",
    "    NomCounter(\"sex\"),\n",
    "    NumCounter(\"capital-gain\"),\n",
    "    NumCounter(\"capital-loss\"),\n",
    "    NumCounter(\"hours-per-week\"),\n",
    "    NomCounter(\"native-country\"),\n",
    "    ClassCounter(\"salary\")\n",
    ")\n",
    "model.set_filters((\"?\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''Wine Dataset'''\n",
    "'''-----------------------------------------------------------------------------'''\n",
    "filename = \"datasets/wine.data\"\n",
    "classes = (\"1\" , \"2\", \"3\")\n",
    "model = Model(\n",
    "    classes,\n",
    "    ClassCounter(\"Alcohol\"),\n",
    "    NumCounter(\"age\"),\n",
    "    NumCounter(\"Malic acid\"),\n",
    "    NumCounter(\"Ash\"),\n",
    "    NumCounter(\"Alcalinity of ash\"),\n",
    "    NumCounter(\"Magnesium\"),\n",
    "    NumCounter(\"Total phenols\"),\n",
    "    NumCounter(\"Flavanoids\"),\n",
    "    NumCounter(\"Nonflavanoid phenols\"),\n",
    "    NumCounter(\"Proanthocyanins\"),\n",
    "    NumCounter(\"Color intensity\"),\n",
    "    NumCounter(\"Hue\"),\n",
    "    NumCounter(\"OD280/OD315 of diluted wines\"),\n",
    "    NumCounter(\"Proline\")\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# The runing model code"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 43,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[59, 71, 48]\n",
      "[14.0, 14.0, 12.0] [59.0, 71.0, 48.0] [69.0, 43.0, 66.0]\n",
      "accuracy is: 0.224719\n",
      "error rate is: 0.775281\n",
      "\n",
      "\n",
      "----------------the macro averaging way------------------\n",
      "Marco averaging precision is:  0.23676604263055223\n",
      "Marco averaging recall is: 0.22815707806158989\n",
      "----------------the micro averaging way------------------\n",
      "Mirco averaging precision is: 0.2247191011235955\n",
      "Mirco averaging recall is: 0.2247191011235955\n",
      "----------------the weight averaging way------------------\n",
      "weight averaging precision is: 0.24614924881906622\n",
      "weight averaging recall is: 0.2247191011235955\n",
      "<class '__main__.Evaluation'>\n",
      "shit\n"
     ]
    }
   ],
   "source": [
    "#weight averaging precision is: 0.871943\n",
    "#weight averaging recall is: 0.715856\n",
    "with open(filename,\"r\") as file:\n",
    "    lines = file.readlines()\n",
    "    model.preprocess(lines)\n",
    "    model.train()\n",
    "    result = model.test(lines)\n",
    "    normal_method = model.evaluate()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.0, 71.0, 0.0] [59.0, 71.0, 48.0] [0.0, 178.0, 0.0]\n",
      "accuracy is: 0.398876\n",
      "error rate is: 0.601124\n",
      "\n",
      "\n",
      "----------------the macro averaging way------------------\n",
      "Marco averaging precision is:  0.13295880149812733\n",
      "Marco averaging recall is: 0.3333333333333333\n",
      "----------------the micro averaging way------------------\n",
      "Mirco averaging precision is: 0.398876404494382\n",
      "Mirco averaging recall is: 0.398876404494382\n",
      "----------------the weight averaging way------------------\n",
      "weight averaging precision is: 0.15910238606236585\n",
      "weight averaging recall is: 0.398876404494382\n",
      "<class '__main__.Evaluation'>\n",
      "shit\n"
     ]
    }
   ],
   "source": [
    "with open(filename,\"r\") as file:\n",
    "    lines = file.readlines()\n",
    "    model.preprocess(lines)\n",
    "    model.train_zero_R_baseline()\n",
    "    result = model.test_zero_R_baseline(lines)\n",
    "    baseline_method = model.evaluate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Evaluation between method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "def compare_two_evaluation_class(evaluation1, evaluation2):\n",
    "        #generate the value throught the function inside the Evaluation class\n",
    "        accuracy1 = evaluation1.calculate_accuracy()\n",
    "        accuracy2 = evaluation2.calculate_accuracy()\n",
    "        precision1,recall1 = evaluation1.calculate_Macro_value()\n",
    "        precision2,recall2 = evaluation2.calculate_Macro_value()\n",
    "        \n",
    "        \n",
    "        #generate the x-axis\n",
    "        value_names = ['accuracy', 'precision','recall']\n",
    "        #generate the two y-axis\n",
    "        values1 = [accuracy1,precision1,recall1]\n",
    "        values2 = [accuracy2,precision2,recall2]\n",
    "        \n",
    "        \n",
    "        #draw the bar chart\n",
    "        plt.figure(figsize=(10,6), dpi=80)\n",
    "        x = range(len(value_names))\n",
    "\n",
    "        m1 = plt.bar(x, values1, width=0.1)\n",
    "        m2 = plt.bar([i + 0.1 for i in x], values2, width=0.1)\n",
    "\n",
    "        plt.xticks([i + 0.05 for i in x], value_names)\n",
    "        #draw the legend\n",
    "        plt.legend((m1,m2),(\"method1\",\"method2\"), loc=\"upper right\")\n",
    "        \n",
    "        #lable the value\n",
    "        def autolabel(rects): \n",
    "            for rect in rects:\n",
    "                height = rect.get_height()\n",
    "                plt.text(rect.get_x()+rect.get_width()/2., 1.03*height, '%s' % float(height))\n",
    "\n",
    "        autolabel(m1)\n",
    "        autolabel(m2)\n",
    "        \n",
    "        #label x and y axis name\n",
    "        plt.xlabel('value name', fontsize=14)\n",
    "        plt.ylabel('precentage', fontsize=14)\n",
    "        #show the figure\n",
    "        plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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3po3b+6LFi3yLVu2+HHHHVco1r9/f3/llVdC7+fMmeMNGjTw1NTUYs8lIiLlJy8vz3Nzcz0nJ0evcnzlzzUsCZoTUOGviFsdSH4WHx9PmzZtmDhxIgMHDmTq1KkkJSWRlJRUqNyKFSto2rQpUVFRZGZmMnPmTK677jogsGJOTEwMVapUYe3atTz//PPMmDEDgMaNG/PBBx9w5513Ehsby3vvvcfpp58eir322mvs2rWLatWq8d5779GyZUuio6NDnztu3Dj69u1baPz8SSedRLdu3fjggw/o2bMn69atY+3atTRv3pyuXbsyZMiQUNmkpCRmzpwZ+sySrnXIkCEl1uvRo0ep5/z+++9DcxIeeeQRzj//fJo0aUKTJk24+uqrQ/W6du3Kn/70J3r37k1OTg5r166ladOmACxYsICMjAwaN24cWiXo448/5txzz+XHH3/k888/589//jMAn3zyCb/97W+ZMWMGrVu3/iW/dhERKYO8vDwyMjLYvn07gXtSKW+xsbEkJiZSqVKlw92UiKQkIMKNGTOGgQMHMmLECGrUqMGrr74KQM+ePRk6dCjt2rVjypQpvPHGG8TGxpKbm0v//v353e9+B8CaNWu44ooriImJISYmhqeeeio0fv+2227jf//7H61ataJSpUrUrVuXMWPGANC3b18WLlxIu3btqFy5MtWrV2fixImhdrk748ePZ9y4cQe0+YUXXuCGG27g3nvvJTo6mrFjxxaaHBzutf4aDz74IJ999hk5OTl06tSJl19++aB1cnNzGThwIDt27CA6OpqqVavy9ttvU6tWLQAmT57MXXfdRU5ODvv37+dPf/oT7du3B+DGG28kKyuL66+/PnS+CRMm0KpVq199LSIi8rN169YRFRVFUlLSAUs/y6/n7mzdupX169fTpEmTw92ciGSRlt0mJCR4enr64W6GiIiIHKHy8vJCveD5C0pI+cvJyWHVqlU0b948tOpgPjPb6O5a+aICaWKwiIiISAH5D0iLLigh5Sv/+420B9JHCiUBIiIiIiIRRn1cIiIiImWQNOSfFXLetMd6Vch5i5OamsrKlSu54oorQsfMjMzMTKpVq/aLz5uWlka7du1CG1j279+fefPm8f333//qc0vFUE+AiIiISIRITU1l8uTJFf45gwYNIjU1tcI/R365w5IEmFlTM5tnZivNbIGZnVpK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/fTTadWqFaNGjQrF5s+fT0pKCikpKZx22mnccsstZGVlheJff/01Xbt2pWXLljRv3pxp06YB8Nprr4XqpaSkcNJJJ3HZZZeF6q1fv54+ffrQvHlzWrRoUegzS4vNnDmTFi1a0KRJE/r168euXbsKXYu7061bN0466aRCbTznnHNo0aIFrVq14uabby50Ddu2bWPAgAE0bdqUli1bMmTIEAB2795Nx44dad26Na1bt+aiiy4iLS0tVO+LL74gJSWFZs2a0a1bN77//vtQzMxITk4OXf+nn3560NimTZu48MILad68OcnJyVxxxRX89NNPAOzbt49LL72UZs2akZKSckBbrr/++tA527dvz4cffnjA71lEpCKYu5e9sFkWgRvzj8wsGtgPtHP3xWZ2PvBPdy/1ibyZxQMrgZPcPcfMDPgeONPd00qpNxOY5O4TzawrMNLd25W58UEJCQmenp4ebrUj38PHH4LP2FHxnyEiAJx//vlce+21DBw4kLfffpu///3vzJ8/v1CZuXPncsopp1CnTh127NjBGWecwauvvspZZ53Fnj17iI2NJTY2lry8PPr370/Xrl0ZPHgwe/bsoVWrVrz66qt06dKFnJwctm3bxsknn3xAO1q1asXDDz9Mv379cHfatWvHkCFDuPzyy3F3Nm/eTJ06dUqN7dq1i1NOOYWPP/6YFi1acPvtt1O9enUeffTR0OeMGjWK1NRUZsyYwY8//ggEEqG9e/eSnJxMbm4uV199Na1bt+b+++8HoG/fvpx11ln86U9/AuD777+nbt265OXlsXv3bqpXrw7AP/7xDz755BOmTZuGu9O0aVNeeuklunbtysiRI/nyyy958803gcCNfmZmJtWqVTvguygptnnzZlatWkWXLl0AuOeee9ixYwdjx45l3759fPTRR/To0QMz49lnn+Xdd9/l3//+NwDbt2+nZs2aAKSmptK9e3e2bNlC4L9GkTI4FP//wyG/BzCzje6ecEg/NMKE2xOQDrQqIdYGWFOGczQANrl7DoAHspD1QGJJFYLDhToBHxU43NzMFpvZQjO7tZS6d5lZev6r6NMnEZEjTUZGBosXL+aaa64BoF+/fqxdu7bQE2SAs846izp16gBw/PHH06JFC9auXQtAlSpViI2NBSA7O5u9e/cSFRX4J/+NN96gU6dOoZvWmJiYYhOABQsWsHnz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sjIaN25Mly5dKh+LFy+unPfGG2+kY8eOdOnSheOOO445c+ZU1k2YMKGyP127duXxxx+v07ZeeOGFtG7dmojgz3/+c42v1VVXXbVF/RNPPEH37t3p3Lkzxx13HAsWLKise/nll+nVqxddu3altLSU66+/vrLurrvuolOnTjRu3Jjf/OY3VdYzevRoSktLOfroo+nZsyfPPvvJV9uFF15Y5XXZc889ufXWW2v9X2yrTlJ+fapfDP6spJQWAr1qKB9Q9HwxULKV+UcDo3daByUpB4YNG8b3v/99zj//fCZPnszQoUOZNWtWlTYHHXQQv/71r5k3bx5PP/10lbp+/fpx5plnsscee7B+/XpOPPFEjj32WM444wxKSkp4/PHHOfDAA/nggw845phj6NatGyeccALjxo3jlVdeYe7cuTRp0oQLLriAW265hZ/85CcAfPGLX2T+/PlbhtO4DwAAGAFJREFU9HfBggXcdtttvPbaazRv3pwJEyYwYsQIZs+ezXvvvcfw4cNZuHAhBx10EDNmzOAb3/gGK1asqHVbBw4cyGWXXcaJJ55Y4+s0d+5cXnrpJVq1+uT+FatWrWLQoEG88MILlJaWMn36dM4555zKkPC9732Pq666ijPOOIP33nuP9u3bc9ppp9GhQweOOeYYJk6cyLXXXrvFur761a9yxRVXsNdee7FgwQJOOukk3n777So7/ADvvPMObdq04Zvf/Gat/4tt1UnKL38xWJJyaMWKFcydO5dBgwojM8866yzeeustysrKqrQrKSmhZ8+eNGvWbItl7LPPPuyxR+FrZO3ataxbt65y+oQTTuDAAw8EoEWLFrRv35633noLKOzM9+vXj6ZNmxIRDBgwgHvvvbdO/d6wYQNr1qwB4P3336ekpHCsaPPmzaSUqLgDXHFdbdvau3fvyrbVrVu3jhEjRnD77bdTuIStYPHixbRs2ZLS0lIA+vTpw5IlS5g7d25lm/fffx+ANWvW0LRpU/bbbz8Ajj76aEpLSytfq2KnnHIKe+21FwCdOnVi06ZNrFy5cot299xzD/379698jbf1v9hWnaT88lNAknJo2bJlHHzwwTRuXDghHBG0atWKpUvrfI8GAGbOnEnnzp1p2bIlJ598MqeeeuoWbV5//XVmzZpF3759AejRowdTp07lo48+Yv369dx///1VwseHH35Ijx496Nat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\n",
      "text/plain": [
       "<Figure size 800x480 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "compare_two_evaluation_class(normal_method, baseline_method)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
